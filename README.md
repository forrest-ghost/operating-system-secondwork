# operating-system-secondwork
## 2.1.3 代码理解

> 示例代码理解

示例代码部分，消费者有两个信号量:消费者同步信号量键值cons_key和消费者互斥信号量键值cmtx_key，其中同步信号量用于判断是否有产品，cons_sem初值设置为0，表示无产品，消费者阻塞，同时在消费产品后，消费者也会通过V(prod_sem)唤醒阻塞的生产者，最大值为缓冲区的大小；互斥信号量用于和其它的消费者竞争缓冲区的访问权限，同时只允许一个消费者访问缓冲区消费产品，通过P(cmtx_sem)限制当前只允许本消费者使用，在使用完后再通过V(cmtx_sem)唤醒其它的消费者。

生产者有两个信号量：生产者同步信号量键值prod_key和生产者互斥信号量键值pmtx_key,其中同步信号量用于判断当前的缓冲区是否为空，prod_key初值设置为缓冲区大小，若为0表示缓冲区已满，则生产者阻塞，同时在生产产品放到缓冲区以后，生产者也会通过V(cons_sem)唤醒阻塞的消费者；互斥信号量用于和其它的生产者竞争缓冲区访问权限，同一时刻只允许一个生产者访问缓冲区，将产品放到缓冲区，通过P(pmtx_sem)限制仅允许当前的生产者访问共享缓冲区，在使用完后，通过V(pmtx_sem)唤醒其它阻塞的生产者。

> 独立实验代码讲解

抽烟者问题中有两个生产者，三个不同的消费者，其中每个生产者提供轮流提供三种材料中的两种，将他们提供的这两种材料视为一个整体，就有三种材料A,B,C,而同时只能有一个生产者放产品，所以缓冲区大小为1；三个消费者的同步信号量分别为glue_sem,paper.sem,tobacco.sem。

两个生产者的同步信号量键值为empty_key，empty_sem初值为1,互斥信号量键值为pmtx_key,pmtx_sem初值为1，由于在这里缓冲区大小为1，同步信号量大小也为1，互斥信号量可以不使用。在生产者生产产品前，通过P(empty_sem)查看缓冲区是否为空，若非空则生产产品放入缓冲区，否则本进程阻塞。同时在放入产品后，根据放入的材料唤醒对应的消费者，例如放入的是烟草和胶水，那么唤醒拥有纸的消费者，对应V(paper_sem)。

消费者的进程大体相同,例如以拥有纸的消费者为例，通过P(paper_sem)查看缓冲区中除了纸以外的其它两种材料是否具备，如果具备则该进程被唤醒，消费者消费当前产品，最后通过V(empty_sem)唤醒阻塞的生产者。

> provider进程运行结果如下:
![provider](https://github.com/forrest-ghost/image-folder/blob/main/third_os_machine00.png)

> paper进程运行结果:
![paper](https://github.com/forrest-ghost/image-folder/blob/main/third_os_machine01.png)

> glue进程运行结果:
![glue](https://github.com/forrest-ghost/image-folder/blob/main/third_os_machine02.png)

> tobacco进程运行结果：
![tobacco](https://github.com/forrest-ghost/image-folder/blob/main/third_os_machine03.png)

## 实验总结
通过本次实验，我了解到，在操作系统中进程同步的实现是通过一个同步进程信号量，其值一般为共享缓冲区的大小，当多个进程要并发执行时，通过对同步信号量执行P操作获得一个缓冲区资源，当缓冲区资源被申请完后，再申请缓冲区资源的进程将会阻塞，直到有进程释放缓冲区资源后，其它进程才能申请到一个资源，从而执行。总的来说，进程同步的实现是通过多个进程的一块共享缓冲区资源的申请，当有足够的缓冲区资源时，这些进程就都能够获得执行，实现同步。

而互斥的实现是通过互斥信号量，一般互斥信号量的初值为1，所有的进程在执行时先通过P操作将互斥信号量减为0，限制当前只允许本进程执行，其它进程想执行时在P操作互斥信号量时会发现互斥信号量已经为0，无法继续操作，直到当前进程执行完，或者通过V操作释放互斥信号量，其它进程才能继续执行。

